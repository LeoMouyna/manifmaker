<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: both/service/AvailabilityService.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: both/service/AvailabilityService.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {TimeSlotService} from "./TimeSlotService"

export class AvailabilityService {
        /**
         * @memberOf AvailabilityService
         * @summary For a giver user get availability which start at least before param start and end at most after end param.
         * @locus Anywhere
         * @param {User} user
         * @param {Date}start
         * @param {Date} end
         * @returns {availability|null}
         */
        static getSurroundingAvailability(user, start, end) {
            console.info("AvailabilityService.getAvailability start:", start, "end", end, "for user", user);
            var found;
            var start = new moment(start);
            if (typeof end === "undefined") var end = new moment(start);
            else
                var end = new moment(end);
            var end = new moment(end);
            user.availabilities.forEach(availability => {
                var availabilityStart = new moment(availability.start);
                var availabilityEnd = new moment(availability.end);
                if (( availabilityStart.isBefore(start) || availabilityStart.isSame(start))
                    &amp;&amp; (availabilityEnd.isAfter(end) || availabilityEnd.isSame(end) )) {
                    found = availability;
                    return false;
                }
            });
            return found;
        }

        /**
         * @memberOf AvailabilityService
         * @summary For a giver user get availability index which start at least before param start and end at most after end param.
         * @locus Anywhere
         * @param {User} user
         * @param {Date}start
         * @param {Date} end
         * @returns {availabilityId|null}
         */
        static getIndexOfSurroundingAvailability(user, start, end) {
            console.info("AvailabilityService.getAvailability start:", start, "end", end, "for user", user);
            var found;
            var start = new moment(start);
            if (typeof end === "undefined") var end = new moment(start);
            else
                var end = new moment(end);
            var end = new moment(end);
            user.availabilities.forEach(function (availability, index, availabilities) {
                var availabilityStart = new moment(availability.start);
                var availabilityEnd = new moment(availability.end);
                if (( availabilityStart.isBefore(start) || availabilityStart.isSame(start))
                    &amp;&amp; (availabilityEnd.isAfter(end) || availabilityEnd.isSame(end) )) {
                    found = index;
                    return false;
                }
            });
            return found;
        }

        /**
         * @memberOf AvailabilityService
         * @summary For a giver user splice and merge availabilities in order to make him unavailable between start and end params.
         * @locus Anywhere
         * @param {User} user
         * @param {Date}start
         * @param {Date} end
         */
        static removeAvailabilities(user, start, end) {
            console.info("AvailabilityService.splitAvailabilities for user", user, " from", start, "to", end);
            var availabilities = user.availabilities;

            var availabilityIndex = AvailabilityService.getIndexOfSurroundingAvailability(user, start, end);
            //remove old availability
            var availability = availabilities.splice(availabilityIndex, 1)[0];
            //add new availabilities and prevent creating a 0minutes availability
            if (!new moment(availability.start).isSame(new moment(start)))
                availabilities.push({
                    start: availability.start,
                    end: start
                });
            if (!new moment(end).isSame(new moment(availability.end)))
                availabilities.push({
                    start: end,
                    end: availability.end
                });

            Users.update({_id: user._id}, {$set: {availabilities: availabilities}});

        }

        /**
         * @memberOf AvailabilityService
         * @summary Read the name...
         * @locus Anywhere
         * @param {User} user
         * @param {Date}start
         * @returns {availability|null}
         */
        static getIndexOfAvailabilityWhichEndWhenParamStart(user, start) {
            console.info("AvailabilityService.getIndexOfAvailabilityWhichEndWhenParamStart start:", start, "for user", user);
            var found;
            var start = new moment(start);

            user.availabilities.forEach(function (availability, index, availabilities) {
                var availabilityEnd = new moment(availability.end);
                if (availabilityEnd.isSame(start)) {
                    found = index;
                    return false;
                }
            });
            return found;
        }

        /**
         * @memberOf AvailabilityService
         * @summary Read the name...
         * @locus Anywhere
         * @param {User} user
         * @param {Date}start
         * @returns {availabilityId|null}
         */
        static getIndexOfAvailabilityWhichStartWhenParamEnd(user, end) {
            console.info("AvailabilityService.getIndexOfAvailabilityWhichStartWhenParamEnd end:", end, "for user", user);
            var found;
            var end = new moment(end);

            user.availabilities.forEach(function (availability, index, availabilities) {
                var availabilityStart = new moment(availability.start);
                if (availabilityStart.isSame(end)) {
                    found = index;
                    return false;
                }
            });
            return found;
        }

        /**
         * @memberOf AvailabilityService
         * @summary For a giver user add and merge availabilities in order to make him available between start and end params.
         * @locus Anywhere
         * @param {User} user
         * @param {Date}start
         * @param {Date} end
         */
        static restoreAvailabilities(user, start, end) {
            console.info("AvailabilityService.restoreAvailabilities for user", user, " from", start, "to", end);
            var availabilities = user.availabilities;
            var previousAvailability, nextAvailability;

            //if exits, get direct previous availabilty
            var previousAvailabilityIndex = AvailabilityService.getIndexOfAvailabilityWhichEndWhenParamStart(user, start);

            //if exits, get direct next availabilty
            var nextAvailabilityIndex = AvailabilityService.getIndexOfAvailabilityWhichStartWhenParamEnd(user, end);


            //if possible

            //remove old availability(ies)
            if (typeof previousAvailabilityIndex !== "undefined") {
                previousAvailability = availabilities.splice(previousAvailabilityIndex, 1)[0];
            }
            if (typeof nextAvailabilityIndex !== "undefined") {
                nextAvailability = availabilities.splice(nextAvailabilityIndex, 1)[0];
            }

            var newAvailability = {};

            //merge availability
            if (previousAvailability) {
                newAvailability.start = previousAvailability.start;
            } else {
                newAvailability.start = start;
            }
            if (nextAvailability) {
                newAvailability.end = nextAvailability.end;
            } else {
                newAvailability.end = end;
            }

            availabilities.push(newAvailability);

            Users.update({_id: user._id}, {$set: {availabilities: availabilities}});

        }

        /**
         * @memberOf AvailabilityService
         * @summary Proxy for TimeSlotService.getTimeSlotByStart
         * @locus Anywhere
         * @param {Array&lt;Availability>} availabilities
         * @param {Date}start
         * @return {timeSlot|null}
         */
        static getAvailabilityByStart(availabilities, start) {
            return TimeSlotService.getTimeSlotByStart(availabilities, start);
        }

        /**
         * @memberOf AvailabilityService
         * @summary Return true if user is available between start and end params.
         * @locus Anywhere
         * @param {Array&lt;Availability>} availabilities
         * @param {Date}start
         * @param {Date} end
         * @return {boolean}
         */
        static checkUserAvailabilty(user, start, end) {
            console.info("AvailabilityService.checkUserAvailabilty for user", user, " from", start, "to", end);
            var availabilities = user.availabilities;

            var availabilityIndex = AvailabilityService.getIndexOfSurroundingAvailability(user, start, end);

            if (availabilityIndex == null) {
                return false;
            }
            return true;


        }
    }
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="-_.html"></a></li><li><a href="AssignmentServiceClient.html">AssignmentServiceClient</a></li><li><a href="InjectDataServerService.html">InjectDataServerService</a></li><li><a href="Leaf.html">Leaf</a></li><li><a href="SecurityServiceClient.html">SecurityServiceClient</a></li><li><a href="SecurityServiceServer.html">SecurityServiceServer</a></li><li><a href="ServerAssignmentService.html">ServerAssignmentService</a></li><li><a href="ServerReferenceCollectionsService.html">ServerReferenceCollectionsService</a></li><li><a href="ServerTaskService.html">ServerTaskService</a></li><li><a href="ServerUserService.html">ServerUserService</a></li></ul><h3>Namespaces</h3><ul><li><a href="Collection.html">Collection</a></li><li><a href="EasySearch.html">EasySearch</a></li><li><a href="Enum.html">Enum</a></li><li><a href="Meteor%2520Methods.html">Meteor Methods</a></li><li><a href="Meteor_Publish.html">Meteor_Publish</a></li><li><a href="Route.html">Route</a></li><li><a href="Route.Assignment.html">Assignment</a></li><li><a href="Route.Assignment.taskToUser.html">taskToUser</a></li><li><a href="Route.Assignment.userToTask.html">userToTask</a></li><li><a href="Route.collectionReference.html">collectionReference</a></li><li><a href="Route.common.html">common</a></li><li><a href="Route.Task.html">Task</a></li><li><a href="Route.User.html">User</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Jun 20 2016 16:36:23 GMT+0200 (Paris, Madrid (heure d’été))
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
